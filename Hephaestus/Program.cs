using System.Text;
using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;

namespace Hephaestus
{
    public class Program
    {
        static Lazy<Settings> _settings = null!;
        public static Settings settings => _settings.Value;

        public static async Task<int> Main(string[] args)
        {
            // Run the patcher
            return await SynthesisPipeline
                .Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Hephaestus.esp")
                .SetAutogeneratedSettings("Settings", "settings.json", out _settings)
                .Run(args);
        }

        private static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            //Declare base vars and dictionaries
            char[] vowels = { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };
            Dictionary<FormKey, List<FormKey>> itemCOBJs = new();
            Dictionary<FormKey, List<FormKey>> itemLVLIs = new();
            Dictionary<FormKey, FormKey> itemBOOK = new();
            Dictionary<FormKey, FormKey> itemBOOKPlayer = new();
            Dictionary<FormKey, FormKey> itemBOOKFragment = new();
            Dictionary<FormKey, Dictionary<string, FormKey>> bookLVLIs = new();

            // LVLI Whitelist base
            List<FormKey> lootLVLIWhitelist = new();
            lootLVLIWhitelist.AddRange(GenData.lootLVLIWhitelistBase);
            if (settings.distributeVendors)
                lootLVLIWhitelist.AddRange(GenData.lootLVLIWhitelistVendor);
            if (settings.distributeGeneralLoot)
                lootLVLIWhitelist.AddRange(GenData.lootLVLIWhitelistLoot);
            if (settings.distributeBlacksmiths)
                lootLVLIWhitelist.AddRange(GenData.lootLVLIWhitelistBlacksmith);
            if (settings.distributeSpecial)
                lootLVLIWhitelist.AddRange(GenData.lootLVLIWhitelistSpecial);

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(string.Empty);
            Console.WriteLine("Building cache ...");
            Console.WriteLine(string.Empty);

            // Set of all form keys that appear as entries in leveled lists

            var cobjProducts = state.LoadOrder.PriorityOrder.ConstructibleObject().WinningOverrides()
                .Select(cobj => cobj.CreatedObject.FormKey)
                .ToHashSet();

            foreach (var baseLVLI in state.LoadOrder.PriorityOrder.LeveledItem().WinningOverrides()) {
                if (baseLVLI.Entries == null)
                    continue;
                foreach (var entry in baseLVLI.Entries) {
                    if (entry.Data != null && cobjProducts.Contains(entry.Data.Reference.FormKey)) {
                        if (!itemLVLIs.ContainsKey(entry.Data.Reference.FormKey))
                            itemLVLIs.Add(entry.Data.Reference.FormKey, new List<FormKey>());
                        if (!itemLVLIs[entry.Data.Reference.FormKey].Contains(baseLVLI.FormKey))
                            itemLVLIs[entry.Data.Reference.FormKey].Add(baseLVLI.FormKey);
                    }
                }
            }

            // Enumerate through COBJs and save the data for later for the items that have names and values, for which the COBJ has a whitelisted keyword and which are present in at least one leveled list
            foreach (
                IConstructibleObjectGetter baseCOBJ in state
                    .LoadOrder
                    .PriorityOrder
                    .ConstructibleObject()
                    .WinningOverrides()
            )
            {
                // Sanity checks to skip unnecessary processing
                if (
                    baseCOBJ.Items == null
                    || !settings
                        .BenchSettings
                        .Any(e => e.BenchKeyword.FormKey == baseCOBJ.WorkbenchKeyword.FormKey)
                    || !baseCOBJ.CreatedObject.TryResolve(state.LinkCache, out var createdItem)
                )
                    continue;

                // Skip if in blacklist
                if (settings.itemBlacklist == null || settings.itemBlacklist.Contains(createdItem))
                    continue;

                // Skip if item value can't be grabbed
                if (createdItem is not IWeightValueGetter && createdItem is not IWeaponGetter)
                    continue;

                // if no relevant LVLIs, skip item early
                if (!itemLVLIs.ContainsKey(createdItem.FormKey))
                    continue;

                // add COBJ now since it's already passed the LVLI check
                if (!itemCOBJs.ContainsKey(createdItem.FormKey))
                    itemCOBJs.Add(createdItem.FormKey, new List<FormKey>());
                itemCOBJs[createdItem.FormKey].Add(baseCOBJ.FormKey);
            }

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(string.Empty);
            Console.WriteLine("Assigning item types and prepping things ...");

            foreach (var createdItemFormKey in itemCOBJs.Keys)
            {
                // Pull created item
                if (
                    !state
                        .LinkCache
                        .TryResolve<IItemGetter>(createdItemFormKey, out var createdItem)
                    || createdItem is not INamedGetter createdItemName
                    || createdItem is not IKeywordedGetter createdItemKeywords
                )
                    continue;

                if (settings.ShowDebugLogs)
                {
                    Console.WriteLine(string.Empty);
                    Console.WriteLine("=======================");
                    Console.WriteLine(string.Empty);
                    Console.WriteLine($"Found {createdItemName.Name} ...");
                }
                else
                    Console.WriteLine($"Patching for {createdItemName.Name} ...");

                // Deterministic seed
                var random = new Random(createdItem.FormKey.ID.GetHashCode());

                // Base Object
                string? objName = createdItemName.Name;
                string? objEditorID = createdItem.EditorID;
                uint objValue;
                string? objType = "Misc";

                if (createdItem is IWeightValueGetter createdItemValue)
                    objValue = createdItemValue.Value;
                else if (createdItem is IWeaponGetter createdWeapon)
                    objValue = createdWeapon.BasicStats?.Value ?? 10;
                else
                    continue;

                // Book variables
                Book book;
                Book bookPlayer;
                Book bookFragment;

                // Randomize book model
                var bookModelSetKey = GenData
                    .bookModelLib
                    .Keys
                    .ElementAt(
                        (int)
                            Math.Round(
                                (GenData.bookModelLib.Count - 1) * (float)random.NextDouble()
                            )
                    );
                if (!state.LinkCache.TryResolve<IStaticGetter>(bookModelSetKey, out var bookStatic))
                    continue;

                // Randomize fragment model
                var bookFragmentModelSetKey = GenData
                    .bookFragmentModelLib
                    .Keys
                    .ElementAt(
                        (int)
                            Math.Round(
                                (GenData.bookFragmentModelLib.Count - 1)
                                    * (float)random.NextDouble()
                            )
                    );
                if (
                    !state
                        .LinkCache
                        .TryResolve<IStaticGetter>(
                            bookFragmentModelSetKey,
                            out var bookFragmentStatic
                        )
                )
                    continue;

                // Initialize other
                string? requiredItems = string.Empty;
                string? aAn;
                if (objName?.IndexOfAny(vowels) == 0)
                    aAn = "an ";
                else if (
                    (createdItemFormKey == Skyrim.MiscItem.LeatherStrips.FormKey)
                    || (createdItemFormKey == Skyrim.MiscItem.Leather01.FormKey)
                )
                    aAn = "";
                else
                    aAn = "a ";

                // Assigning item types
                switch (createdItem)
                {
                    case IWeaponGetter:
                        objType = "Weapon";
                        break;
                    case IIngestibleGetter:
                        objType = "Cooking";
                        break;
                    case IArmorGetter armorObj:
                        var flagToCheck = armorObj.BodyTemplate;
                        if (flagToCheck == null)
                            continue;
                        switch (flagToCheck.FirstPersonFlags)
                        {
                            case BipedObjectFlag.Hands
                            or BipedObjectFlag.Feet:
                                aAn = "a pair of ";
                                break;
                            case BipedObjectFlag.Amulet
                            or BipedObjectFlag.Ring:
                                objType = "Jewelry";
                                break;
                            case BipedObjectFlag.Head:
                                objType = "Helmet";
                                break;
                            default:
                                objType = "Armor";
                                break;
                        }
                        if (armorObj.EquipmentType.FormKey == Skyrim.EquipType.Shield.FormKey)
                        {
                            objType = "Shield";
                        }
                        break;
                }

                if (settings.ShowDebugLogs)
                {
                    Console.WriteLine(string.Empty);
                    Console.WriteLine($"Creating {objName} schematics and patching COBJs ...");
                }

                foreach (FormKey cobjFormKey in itemCOBJs[createdItemFormKey])
                {
                    // Define COBJ
                    if (
                        !state
                            .LinkCache
                            .TryResolve<IConstructibleObjectGetter>(cobjFormKey, out var cobj)
                    )
                        continue;

                    // Set values based on bench
                    var curBenchSettings = settings.BenchSettings[
                        settings
                            .BenchSettings
                            .FindIndex(e => e.BenchKeyword.FormKey == cobj.WorkbenchKeyword.FormKey)
                    ];
                    string objBench = curBenchSettings.objBenchName ?? "crafting bench";
                    string schematicType = curBenchSettings.schematicTypeName ?? "Schematic";
                    string processName = curBenchSettings.processName ?? "craft";
                    string processNameCont = $"{processName}ing";

                    if (vowels.Any(e => e == processName[processName.Length - 1]))
                        processNameCont = $"{processName.Substring(0, processName.Length - 1)}ing";

                    if (cobj.Items == null)
                        continue;
                    foreach (var reqItem in cobj.Items)
                    {
                        if (!reqItem.Item.Item.TryResolve(state.LinkCache, out var reqItemObj))
                            continue;
                        if (reqItemObj is not INamedGetter namedItem)
                            continue;
                        requiredItems += $"{namedItem.Name}\n";
                    }
                    ;

                    // Building the flavour text
                    if (!itemBOOK.ContainsKey(createdItem.FormKey))
                    {
                        // Define how many times an item needs to be broken down
                        int min = 5;
                        int max = 10;
                        uint noteToSchematicRatio = (uint)
                            Math.Max(Math.Round(min + (max - min) * (float)random.NextDouble()), 1);

                        // NPC name lists
                        List<string> NPCNames = settings.LovedOnesName;

                        // Name generation for schematic data
                        if (createdItemKeywords.Keywords != null)
                        {
                            List<string> equipment =
                                new() { "Armor", "Weapon", "Shield", "Jewelry" };

                            // if it's equipment, generate based on races, otherwise don't
                            if (equipment.Contains(objType))
                            {
                                if (
                                    createdItemKeywords
                                        .Keywords
                                        .Contains(Skyrim.Keyword.WeapMaterialElven)
                                    || createdItemKeywords
                                        .Keywords
                                        .Contains(Skyrim.Keyword.ArmorMaterialElvenGilded)
                                    || createdItemKeywords
                                        .Keywords
                                        .Contains(Skyrim.Keyword.ArmorMaterialElven)
                                    || createdItemKeywords
                                        .Keywords
                                        .Contains(Skyrim.Keyword.WeapMaterialFalmer)
                                    || createdItemKeywords
                                        .Keywords
                                        .Contains(Skyrim.Keyword.WeapMaterialFalmerHoned)
                                )
                                {
                                    NPCNames.AddRange(GenData.ElfNPCNames);
                                }
                                else if (
                                    createdItemKeywords
                                        .Keywords
                                        .Contains(Skyrim.Keyword.WeapMaterialOrcish)
                                    || createdItemKeywords
                                        .Keywords
                                        .Contains(Skyrim.Keyword.ArmorMaterialOrcish)
                                )
                                {
                                    NPCNames = GenData.OrcNPCNames;
                                }
                                else if (
                                    createdItemKeywords
                                        .Keywords
                                        .Contains(Skyrim.Keyword.WeapMaterialDwarven)
                                    || createdItemKeywords
                                        .Keywords
                                        .Contains(Skyrim.Keyword.ArmorMaterialDwarven)
                                )
                                {
                                    NPCNames = GenData.DwemerNPCNames;
                                }
                                else if (
                                    createdItemKeywords
                                        .Keywords
                                        .Contains(Skyrim.Keyword.WeapMaterialDraugr)
                                    || createdItemKeywords
                                        .Keywords
                                        .Contains(Skyrim.Keyword.WeapMaterialDraugrHoned)
                                    || createdItemKeywords
                                        .Keywords
                                        .Contains(Skyrim.Keyword.ArmorMaterialDwarven)
                                )
                                {
                                    NPCNames.AddRange(GenData.NordNPCNames);
                                }
                                else
                                {
                                    NPCNames.AddRange(GenData.NordNPCNames);
                                    NPCNames.AddRange(GenData.HumanNPCNames);
                                    NPCNames.AddRange(GenData.BeastNPCNames);
                                    NPCNames.AddRange(GenData.BlacksmithNPCNames);
                                }
                            }
                            else
                            {
                                NPCNames.AddRange(GenData.NordNPCNames);
                                NPCNames.AddRange(GenData.HumanNPCNames);
                                NPCNames.AddRange(GenData.BeastNPCNames);
                                NPCNames.AddRange(GenData.ElfNPCNames);
                                NPCNames.AddRange(GenData.OrcNPCNames);
                                NPCNames.AddRange(GenData.DwemerNPCNames);
                            }
                        }

                        // create a new book
                        book = state.PatchMod.Books.AddNew($"{objEditorID}_{schematicType}");

                        // Set the book properties
                        book.Name = $"{objType} {schematicType}: {objName}";
                        book.Description =
                            $"A {schematicType.ToLower()} created by {NPCNames[random.Next(NPCNames.Count)]}. It details the process of {processNameCont} {aAn}{objName}.";
                        book.Value = objValue * (noteToSchematicRatio + 2);
                        book.Weight = settings.schematicWeight;
                        book.Model = GenData.bookModelLib[bookModelSetKey];
                        book.InventoryArt = new FormLinkNullable<IStaticGetter>(bookStatic);
                        book.ObjectBounds = bookStatic.ObjectBounds.DeepCopy();
                        book.Type = Book.BookType.BookOrTome;
                        book.PickUpSound = new FormLinkNullable<ISoundDescriptorGetter>(
                            Skyrim.SoundDescriptor.ITMNoteUp.FormKey
                        );
                        book.Keywords = new Noggog.ExtendedList<IFormLinkGetter<IKeywordGetter>>
                        {
                            Skyrim.Keyword.VendorItemRecipe
                        };
                        // Copy keywords from the original item to the generated books
                        // so that they can be sold to blacksmiths
                        if (createdItemKeywords.Keywords != null)
                        {
                            foreach (var keyword in createdItemKeywords.Keywords)
                            {
                                book.Keywords.Add(keyword.FormKey);
                            }
                        }

                        string frontPage =
                            $"<p align='center'>\n\n\n{objName} {schematicType}\n\n\n\n</p>\n[pagebreak]";

                        string otherConditions = string.Empty;

                        if (cobj.Conditions.Count > 0)
                        {
                            otherConditions =
                                $"I understand most of this {schematicType.ToLower()}, but I think I am missing some key knowledge before being able to work with this.";

                            if (
                                (cobj.Conditions[0].Data is HasPerkConditionData cobjPerkCond)
                                && state
                                    .LinkCache
                                    .TryResolve<IPerkGetter>(
                                        cobjPerkCond.Perk.EnumerateFormLinks().ToList()[0].FormKey,
                                        out var cobjPerk
                                    )
                            )
                            {
                                otherConditions =
                                    $"I understand most of this {schematicType.ToLower()}, but I think I am missing some key knowledge on {cobjPerk.Name} before being able to work with this.";
                            }
                        }

                        var congregatedFlavourText = new List<string>(GenData.flavourText);

                        switch (objType)
                        {
                            case "Armor":
                                congregatedFlavourText.AddRange(GenData.ArmorflavourText);
                                break;
                            case "Weapon":
                                congregatedFlavourText.AddRange(GenData.WeaponflavourText);
                                break;
                            case "Shield":
                                congregatedFlavourText.AddRange(GenData.ShieldflavourText);
                                break;
                            case "Cooking":
                                congregatedFlavourText.AddRange(GenData.CookingflavourText);
                                break;
                            case "Jewelry":
                                congregatedFlavourText.AddRange(GenData.JewelryflavourText);
                                break;
                        }

                        StringBuilder randFlavourText = new StringBuilder(
                            congregatedFlavourText[random.Next(congregatedFlavourText.Count)]
                        );
                        randFlavourText.Replace("schematicTypeLower", schematicType.ToLower());
                        randFlavourText.Replace("processNameCont", processNameCont);
                        randFlavourText.Replace("aAn", aAn);
                        randFlavourText.Replace("objBench", objBench);
                        randFlavourText.Replace("objName", objName);

                        book.BookText =
                            $"{frontPage}\n<p align='left'>\nMaterials needed:\n<b>{requiredItems}</b>\n<font face='$HandwrittenFont'>{randFlavourText.ToString()} {otherConditions}</font></p>";
                        ;

                        // Add book to dict
                        itemBOOK.Add(createdItem.FormKey, book.FormKey);

                        if (settings.ShowDebugLogs)
                        {
                            Console.WriteLine($"Created {book.Name}:");
                            Console.WriteLine("-----------------------");
                            Console.WriteLine(book.BookText);
                            Console.WriteLine("-----------------------");
                            Console.WriteLine(string.Empty);
                        }

                        // Add player made schematic

                        // create a new book
                        bookPlayer = state.PatchMod.Books.AddNew($"{book.EditorID}_Player");

                        // Set the book properties
                        bookPlayer.Name = book.Name;
                        bookPlayer.Description =
                            $"A {schematicType.ToLower()} created by me. It details the process of {processNameCont} {aAn}{objName}.";
                        ;
                        bookPlayer.Value = book.Value;
                        bookPlayer.Weight = book.Weight;
                        bookPlayer.Model = book.Model;
                        bookPlayer.InventoryArt = book.InventoryArt;
                        bookPlayer.ObjectBounds = book.ObjectBounds;
                        bookPlayer.Type = book.Type;
                        bookPlayer.PickUpSound = book.PickUpSound;
                        bookPlayer.Keywords = book.Keywords;

                        // Formatting book contents
                        List<string> flavourTextPlayer =
                            new()
                            {
                                $"I spent quite some time on this {schematicType.ToLower()}. The writing is rough, the steps somewhat confusing, but it's easy enough to follow it and {processName} {aAn}{objName} at a {objBench}.",
                                $"I wrote this {schematicType.ToLower()} with great detail. It details the steps of {processNameCont} {aAn}{objName} at a {objBench}.",
                                $"Coming up with this {schematicType.ToLower()} took a lot of practice, you can see it from the scribbles and notes. They describe the steps of {processNameCont} {aAn}{objName} at a {objBench}.",
                            };

                        bookPlayer.BookText =
                            $"{frontPage}\n<p align='left'>\nMaterials needed:\n<b>{requiredItems}</b>\n<font face='$HandwrittenFont'>{flavourTextPlayer[random.Next(flavourTextPlayer.Count)]} {otherConditions}</font></p>";
                        ;

                        // Add book to dict
                        itemBOOKPlayer.Add(createdItem.FormKey, bookPlayer.FormKey);

                        // create a new book fragment
                        bookFragment = state.PatchMod.Books.AddNew($"{book.EditorID}_Fragment");
                        string counter = $"about {noteToSchematicRatio} times";

                        // Set the fragment properties
                        bookFragment.Name = $"{schematicType} notes on {objName}";
                        bookFragment.Description =
                            $"Notes made on the {processNameCont} of {aAn}{objName}.";
                        bookFragment.Value = (uint)
                            Math.Max(
                                Math.Round(objValue / ((double)noteToSchematicRatio * 1.2)),
                                1
                            );
                        bookFragment.Weight = settings.fragmentWeight;
                        bookFragment.Model = GenData.bookFragmentModelLib[bookFragmentModelSetKey];
                        bookFragment.InventoryArt = new FormLinkNullable<IStaticGetter>(
                            bookFragmentStatic
                        );
                        bookFragment.ObjectBounds = bookFragmentStatic.ObjectBounds.DeepCopy();
                        bookFragment.PickUpSound = new FormLinkNullable<ISoundDescriptorGetter>(
                            Skyrim.SoundDescriptor.ITMNoteUp.FormKey
                        );
                        bookFragment.BookText =
                            $"After studying {aAn}{objName} I feel like I've grown closer to understanding how to {processName} it. I will need to repeat this process {counter} if I want to be able to {processName} {aAn}{objName} of my own.";
                        ;
                        bookFragment.Type = Book.BookType.BookOrTome;
                        bookFragment.Keywords = book.Keywords;

                        // Add book fragment to dict
                        itemBOOKFragment.Add(createdItem.FormKey, bookFragment.FormKey);

                        // Create COBJ item -> fragment
                        var itemToFragmentCOBJ = state.PatchMod.ConstructibleObjects.AddNew($"{objEditorID}_Breakdown_Recipe");

                        itemToFragmentCOBJ.CreatedObject =
                            new FormLinkNullable<IConstructibleGetter>(bookFragment.FormKey);

                        itemToFragmentCOBJ.Items = new Noggog.ExtendedList<ContainerEntry>
                        {
                            new ContainerEntry()
                            {
                                Item = new ContainerItem()
                                {
                                    Item = new FormLink<IItemGetter>(createdItem.FormKey),
                                    Count = 1
                                },
                            }
                        };

                        itemToFragmentCOBJ.WorkbenchKeyword = new FormLinkNullable<IKeywordGetter>(
                            cobj.WorkbenchKeyword.FormKey
                        );

                        if (settings.useSmelter)
                        {
                            itemToFragmentCOBJ.WorkbenchKeyword =
                                new FormLinkNullable<IKeywordGetter>(
                                    Skyrim.Keyword.CraftingSmelter.FormKey
                                );
                        }

                        itemToFragmentCOBJ.CreatedObjectCount = (ushort?)
                            itemToFragmentCOBJ.Items.Count;

                        // Add conditions (so it doesn't clutter the menu)
                        // Check we have at least one of the item we're breaking down
                        var itemToFragmentCOBJCond = new GetItemCountConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        ;
                        itemToFragmentCOBJCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                            itemToFragmentCOBJCond,
                            createdItem.FormKey
                        );
                        itemToFragmentCOBJCond.ItemOrList.Link.SetTo(createdItemFormKey);

                        itemToFragmentCOBJ
                            .Conditions
                            .Add(
                                new ConditionFloat()
                                {
                                    ComparisonValue = 1,
                                    CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                    Data = itemToFragmentCOBJCond,
                                }
                            );

                        // Make sure we don't have enough fragments to make a book
                        var notEnoughFragmentsCond = new GetItemCountConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        notEnoughFragmentsCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                            notEnoughFragmentsCond,
                            bookFragment.FormKey
                        );
                        notEnoughFragmentsCond.ItemOrList.Link.SetTo(bookFragment);

                        itemToFragmentCOBJ.Conditions.Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = noteToSchematicRatio,
                                CompareOperator = CompareOperator.LessThan,
                                Data = notEnoughFragmentsCond,
                            }
                        );

                        ConditionFloat CreateNotHaveBookCondition(Book book)
                        {
                            var data = new GetItemCountConditionData()
                            {
                                RunOnType = Condition.RunOnType.Reference,
                                Reference = Skyrim.PlayerRef,
                            };
                            data.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                                data,
                                book.FormKey
                            );
                            data.ItemOrList.Link.SetTo(book);

                            return new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.LessThan,
                                Data = data,
                            };
                        }

                        // Make sure we haven't crafted the book yet
                        // or found one in loot
                        itemToFragmentCOBJ.Conditions.Add(CreateNotHaveBookCondition(book));
                        itemToFragmentCOBJ.Conditions.Add(CreateNotHaveBookCondition(bookPlayer));

                        // Create COBJ fragment -> book
                        var bookCOBJ = state.PatchMod.ConstructibleObjects.AddNew($"{objEditorID}_{schematicType}_Recipe");

                        bookCOBJ.CreatedObject = new FormLinkNullable<IConstructibleGetter>(
                            bookPlayer.FormKey
                        );

                        bookCOBJ.Items = new Noggog.ExtendedList<ContainerEntry>
                        {
                            new ContainerEntry()
                            {
                                Item = new ContainerItem()
                                {
                                    Item = new FormLink<IItemGetter>(bookFragment.FormKey),
                                    Count = (int)noteToSchematicRatio
                                },
                            }
                        };
                        bookCOBJ.WorkbenchKeyword = new FormLinkNullable<IKeywordGetter>(
                            cobj.WorkbenchKeyword.FormKey
                        );
                        bookCOBJ.CreatedObjectCount = (ushort?)bookCOBJ.Items.Count;

                        // Add conditions (so it doesn't clutter the menu)
                        var bookCOBJCond = new GetItemCountConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        ;
                        bookCOBJCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                            bookCOBJCond,
                            bookFragment.FormKey
                        );
                        bookCOBJCond.ItemOrList.Link.SetTo(bookFragment);

                        var bookCOBJCondItem = new ConditionFloat()
                        {
                            ComparisonValue = noteToSchematicRatio,
                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                            Data = bookCOBJCond
                        };

                        bookCOBJ.Conditions.Add(bookCOBJCondItem);

                        if (settings.ShowDebugLogs)
                        {
                            Console.WriteLine($"Created {bookFragment.Name}:");
                            Console.WriteLine("-----------------------");
                            Console.WriteLine(bookFragment.BookText);
                            Console.WriteLine("-----------------------");
                            Console.WriteLine(string.Empty);
                        }
                    }
                    else
                    {
                        // Link to existing book
                        if (
                            !state
                                .LinkCache
                                .TryResolve<IBookGetter>(
                                    itemBOOK[createdItemFormKey],
                                    out var bookLink
                                )
                            || !state
                                .LinkCache
                                .TryResolve<IBookGetter>(
                                    itemBOOKPlayer[createdItemFormKey],
                                    out var bookPlayerLink
                                )
                        )
                            continue;

                        if (
                            (bookLink is not Book BookLinkBook)
                            || (bookPlayerLink is not Book BookPlayerLinkBook)
                        )
                            continue;

                        book = BookLinkBook;
                        bookPlayer = BookPlayerLinkBook;
                    }

                    // Create a new COBJ record with the modified conditions
                    var modifiedCOBJ = state.PatchMod.ConstructibleObjects.GetOrAddAsOverride(cobj);

                    // Blacksmith tutorial workaround

                    if (
                        cobj.FormKey == Skyrim.ConstructibleObject.RecipeWeaponIronDagger.FormKey
                        || cobj.FormKey == Skyrim.ConstructibleObject.RecipeLeatherDeerHide.FormKey
                        || cobj.FormKey == Skyrim.ConstructibleObject.RecipeArmorHideHelmet.FormKey
                    )
                    {
                        var SmithTutorialCond = new GetStageConditionData();
                        SmithTutorialCond.Quest = new FormLinkOrIndex<IQuestGetter>(
                            SmithTutorialCond,
                            Skyrim.Quest.TutorialBlacksmithing.FormKey
                        );
                        SmithTutorialCond
                            .Quest
                            .Link
                            .SetTo(Skyrim.Quest.TutorialBlacksmithing.FormKey);
                        var conditionBase = new ConditionFloat()
                        {
                            ComparisonValue = 10,
                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                            Data = SmithTutorialCond,
                            Flags = Condition.Flag.OR
                        };

                        if (
                            cobj.FormKey
                            == Skyrim.ConstructibleObject.RecipeWeaponIronDagger.FormKey
                        )
                        {
                            conditionBase.ComparisonValue = 10;
                        }
                        else if (
                            cobj.FormKey == Skyrim.ConstructibleObject.RecipeLeatherDeerHide.FormKey
                        )
                        {
                            conditionBase.ComparisonValue = 50;
                        }
                        else if (
                            cobj.FormKey == Skyrim.ConstructibleObject.RecipeArmorHideHelmet.FormKey
                        )
                        {
                            conditionBase.ComparisonValue = 70;
                        }

                        modifiedCOBJ.Conditions.Add(conditionBase);
                    }

                    // Add book conditions
                    var bookCond = new GetItemCountConditionData()
                    {
                        RunOnType = Condition.RunOnType.Reference,
                        Reference = Skyrim.PlayerRef,
                    };
                    bookCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                        bookCond,
                        book.FormKey
                    );
                    bookCond.ItemOrList.Link.SetTo(book);

                    var bookCondPlayer = new GetItemCountConditionData()
                    {
                        RunOnType = Condition.RunOnType.Reference,
                        Reference = Skyrim.PlayerRef,
                    };
                    bookCondPlayer.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                        bookCondPlayer,
                        bookPlayer.FormKey
                    );
                    bookCondPlayer.ItemOrList.Link.SetTo(bookPlayer);

                    modifiedCOBJ
                        .Conditions
                        .Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = bookCond,
                                Flags = Condition.Flag.OR
                            }
                        );

                    modifiedCOBJ
                        .Conditions
                        .Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = bookCondPlayer,
                            }
                        );

                    if (settings.ShowDebugLogs)
                        Console.WriteLine($"    Patched {cobj.EditorID} with {book.EditorID}");
                }

                // Make tempered COBJs also require schematics
                if (settings.TemperReqSchematic)
                {
                    foreach (
                        IConstructibleObjectGetter temperCOBJ in state
                            .LoadOrder
                            .PriorityOrder
                            .ConstructibleObject()
                            .WinningOverrides()
                    )
                    {
                        // Define LVLI and check if it's empty
                        if (
                            temperCOBJ.CreatedObject.FormKey != createdItemFormKey
                            || (
                                temperCOBJ.WorkbenchKeyword.FormKey
                                    != Skyrim.Keyword.CraftingSmithingArmorTable.FormKey
                                && temperCOBJ.WorkbenchKeyword.FormKey
                                    != Skyrim.Keyword.CraftingSmithingSharpeningWheel.FormKey
                            )
                        )
                            continue;

                        if (settings.ShowDebugLogs)
                        {
                            Console.WriteLine(string.Empty);
                            Console.WriteLine(
                                $"Patching tempering COBJs to require new schematics ..."
                            );
                        }

                        // Set up condition
                        var bookCond = new GetItemCountConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        bookCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                            bookCond,
                            itemBOOK[createdItemFormKey]
                        );
                        bookCond.ItemOrList.Link.SetTo(itemBOOK[createdItemFormKey]);

                        // add condition
                        var modifiedTemperCOBJ = state
                            .PatchMod
                            .ConstructibleObjects
                            .GetOrAddAsOverride(temperCOBJ);

                        // Blacksmith tutorial workaround

                        if (
                            temperCOBJ.FormKey
                                == Skyrim.ConstructibleObject.TemperWeaponIronDagger.FormKey
                            || temperCOBJ.FormKey
                                == Skyrim.ConstructibleObject.TemperArmorHideHelmet.FormKey
                        )
                        {
                            var SmithTutorialCond = new GetStageConditionData();
                            SmithTutorialCond.Quest = new FormLinkOrIndex<IQuestGetter>(
                                SmithTutorialCond,
                                Skyrim.Quest.TutorialBlacksmithing.FormKey
                            );
                            SmithTutorialCond
                                .Quest
                                .Link
                                .SetTo(Skyrim.Quest.TutorialBlacksmithing.FormKey);
                            var conditionBase = new ConditionFloat()
                            {
                                ComparisonValue = 30,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = SmithTutorialCond,
                                Flags = Condition.Flag.OR
                            };

                            if (
                                temperCOBJ.FormKey
                                == Skyrim.ConstructibleObject.TemperArmorHideHelmet.FormKey
                            )
                            {
                                conditionBase.ComparisonValue = 90;
                            }

                            modifiedTemperCOBJ.Conditions.Add(conditionBase);
                        }

                        modifiedTemperCOBJ
                            .Conditions
                            .Add(
                                new ConditionFloat()
                                {
                                    ComparisonValue = 1,
                                    CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                    Data = bookCond,
                                    Flags = Condition.Flag.OR
                                }
                            );

                        // Add player book as cond
                        var bookCondPlayer = new GetItemCountConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        bookCondPlayer.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                            bookCondPlayer,
                            itemBOOKPlayer[createdItemFormKey]
                        );
                        bookCondPlayer.ItemOrList.Link.SetTo(itemBOOKPlayer[createdItemFormKey]);

                        modifiedTemperCOBJ
                            .Conditions
                            .Add(
                                new ConditionFloat()
                                {
                                    ComparisonValue = 1,
                                    CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                    Data = bookCondPlayer,
                                }
                            );
                    }
                }

                if (settings.ShowDebugLogs)
                {
                    Console.WriteLine(string.Empty);
                    Console.WriteLine($"Patching LVLIs to include new schematics ...");
                }

                foreach (FormKey lvliFormKey in itemLVLIs[createdItemFormKey])
                {
                    // Define LVLI and check if it's empty
                    if (
                        !state
                            .LinkCache
                            .TryResolve<ILeveledItemGetter>(lvliFormKey, out var leveledList)
                        && leveledList?.Entries == null
                    )
                        continue;

                    // Skip non-whitelisted LVLIs
                    if (
                        !lootLVLIWhitelist.Contains(lvliFormKey)
                        && !settings.LVLIWhitelist.Contains(leveledList)
                    )
                        continue;

                    // Define the LVLI to be made specifically for the schematic
                    LeveledItem schematicLVLI;

                    // basic book entry to be added to schematicLVLI
                    LeveledItemEntry bookEntry = new LeveledItemEntry()
                    {
                        Data = new LeveledItemEntryData()
                        {
                            Reference = new FormLink<IItemGetter>(itemBOOK[createdItemFormKey]),
                            Level = 1,
                            Count = 1
                        }
                    };

                    string leveledItemIDTemplate = $"{objEditorID}_Schematic_Entry";

                    if (!bookLVLIs.ContainsKey(itemBOOK[createdItemFormKey]))
                        bookLVLIs.Add(
                            itemBOOK[createdItemFormKey],
                            new Dictionary<string, FormKey>()
                        );

                    if (!bookLVLIs[itemBOOK[createdItemFormKey]].ContainsKey(leveledItemIDTemplate))
                    {
                        // Create leveled list for each item with a user customizable drop chance
                        schematicLVLI = state.PatchMod.LeveledItems.AddNew(leveledItemIDTemplate);
                        schematicLVLI.ChanceNone = (byte)(100 - settings.DropChance);
                        schematicLVLI.Entries = new Noggog.ExtendedList<LeveledItemEntry>
                        {
                            bookEntry
                        };
                        bookLVLIs[itemBOOK[createdItemFormKey]].Add(
                            schematicLVLI.EditorID!, // We know it's not null
                            schematicLVLI.FormKey
                        );
                    }
                    else
                    {
                        // Link to existing book
                        if (
                            !state
                                .LinkCache
                                .TryResolve<ILeveledItemGetter>(
                                    bookLVLIs[itemBOOK[createdItemFormKey]][leveledItemIDTemplate],
                                    out var schematicLVLILink
                                )
                        )
                            continue;

                        if (schematicLVLILink is not LeveledItem schematicLVLILinkLVLI)
                            continue;

                        schematicLVLI = schematicLVLILinkLVLI;
                    }

                    if (settings.ShowDebugLogs)
                    {
                        Console.WriteLine(string.Empty);
                        Console.WriteLine(
                            $"    Injecting {schematicLVLI.EditorID} in {leveledList.EditorID}"
                        );
                    }

                    for (int i = 0; i < leveledList.Entries?.Count; i++)
                    {
                        var existingEntry = leveledList.Entries[i];
                        if (existingEntry.Data?.Reference.FormKey != createdItem.FormKey)
                            continue;

                        // Get the level of the existing entry
                        short existingLevel = existingEntry?.Data?.Level ?? 1;

                        // Create a new entry with the new item and the same level
                        LeveledItemEntry newEntry = new LeveledItemEntry()
                        {
                            Data = new LeveledItemEntryData()
                            {
                                Reference = new FormLink<IItemGetter>(schematicLVLI),
                                Level = existingLevel,
                                Count = 1
                            }
                        };

                        LeveledItem modifiedBaseLVLI = state
                            .PatchMod
                            .LeveledItems
                            .GetOrAddAsOverride(leveledList);

                        // Add the new entry to the leveled list
                        if (modifiedBaseLVLI.Entries == null)
                            modifiedBaseLVLI.Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                        modifiedBaseLVLI.Entries.Add(newEntry);

                        if (settings.ShowDebugLogs)
                            Console.WriteLine($"        Injected at level {existingLevel};");
                    }
                }

                // Temporary "fix" for hitting the LVLI entry cap

                var overflownFormkeys = new Dictionary<FormKey, List<FormKey>>();

                foreach (var lvliFormKey in itemLVLIs[createdItemFormKey])
                {
                    // Define LVLI and check if it's empty
                    if (
                        !state
                            .LinkCache
                            .TryResolve<ILeveledItemGetter>(lvliFormKey, out var leveledList)
                    )
                        continue;

                    if (leveledList.Entries?.Count >= 254)
                    {
                        if (!overflownFormkeys.ContainsKey(createdItemFormKey))
                            overflownFormkeys.Add(createdItemFormKey, new List<FormKey>());
                        overflownFormkeys[createdItemFormKey].Add(leveledList.FormKey);
                    }
                }

                if (!overflownFormkeys.ContainsKey(createdItemFormKey))
                    continue;

                Console.WriteLine(string.Empty);
                Console.WriteLine($"oopsie doopsie uwu too many items in this leveled list");

                if (
                    overflownFormkeys[createdItemFormKey].Count
                    == itemLVLIs[createdItemFormKey].Count
                )
                {
                    // Define LVLI and check if it's empty
                    if (
                        !state
                            .LinkCache
                            .TryResolve<ILeveledItemGetter>(
                                overflownFormkeys[createdItemFormKey][0],
                                out var leveledList
                            )
                    )
                        continue;

                    foreach (var lvliFormKey in bookLVLIs[itemBOOK[createdItemFormKey]])
                    {
                        // Define LVLI and check if it's empty
                        if (
                            !state
                                .LinkCache
                                .TryResolve<ILeveledItemGetter>(lvliFormKey.Value, out var lvli)
                        )
                            continue;
                        state.PatchMod.LeveledItems.Remove(lvli);
                    }

                    state.PatchMod.Books.Remove(itemBOOK[createdItem.FormKey]);
                    state.PatchMod.Books.Remove(itemBOOKFragment[createdItem.FormKey]);

                    // Delete cobj condition changes, book and book fragment cobjs
                    foreach (var cobj in state.PatchMod.ConstructibleObjects)
                    {
                        if (
                            itemCOBJs[createdItemFormKey].Any(e => e == cobj.FormKey)
                            || cobj.CreatedObject.FormKey == itemBOOK[createdItem.FormKey]
                            || cobj.CreatedObject.FormKey == itemBOOKFragment[createdItem.FormKey]
                        )
                        {
                            state.PatchMod.ConstructibleObjects.Remove(cobj);
                        }
                    }

                    // delete schematic
                    state.PatchMod.LeveledItems.Remove(leveledList);
                    Console.WriteLine($"undoing all the modifications made from this item");
                }
                else
                {
                    foreach (var lvliFormKey in overflownFormkeys[createdItemFormKey])
                    {
                        state.PatchMod.LeveledItems.Remove(lvliFormKey);
                        Console.WriteLine(
                            $"undoing just the funky wunky lvli and keeping the rest"
                        );
                    }
                }
            }

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
        }
    }
}
